package tz.co.victorialush.lushpesa.controllers;

import com.google.gson.Gson;
import jakarta.servlet.http.HttpServletRequest;
import net.minidev.json.JSONObject;
import net.minidev.json.parser.ParseException;
import org.apache.tomcat.util.codec.binary.Base64;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import tz.co.victorialush.lushpesa.models.Credentials;
import tz.co.victorialush.lushpesa.models.Token;
import tz.co.victorialush.lushpesa.plugins.Cryptography;
import tz.co.victorialush.lushpesa.repositories.TokensRepository;
import tz.co.victorialush.lushpesa.services.Authenticate;
import tz.co.victorialush.lushpesa.models.User;
import tz.co.victorialush.lushpesa.plugins.Validator;
import tz.co.victorialush.lushpesa.repositories.UsersRepository;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.*;

@RestController
@RequestMapping(value = "/api")
@CrossOrigin(value = "http://localhost:5173")
public class AuthController {
    private final Map<String, Object> resData = new HashMap<>();

    @Autowired // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private UsersRepository userRepository;

    @Autowired
    Authenticate auth;
    @Autowired
    TokensRepository tokensRepository;
    @Autowired
    ResponseController response;

    @GetMapping(path = "/csrf-token")
    public ResponseEntity<JSONObject> generateCsrfToken(@RequestHeader Map<String, String> headers){
        HttpHeaders resHeaders = new HttpHeaders();
        resHeaders.add("Set-Cookie", "/csrf-token");


        return ResponseEntity.status(HttpStatus.OK).headers(resHeaders).body(null);
    }

    @GetMapping(path = "/sign-out")
    public ResponseEntity<JSONObject> logout(HttpServletRequest request, @RequestHeader Map<String, String> headers) throws NoSuchAlgorithmException {
        String token = (String) request.getAttribute("token");

        if(token != null){
            Optional<Token> tokenEnclosure = tokensRepository.findByToken(Cryptography.hashValue(token));
            if(tokenEnclosure.isPresent()){
                tokensRepository.delete(tokenEnclosure.get());

                response.setSuccess(true);
                response.setMessage("Logged out!");
                response.setData(null);
                response.setStatus(HttpStatus.OK);
            }
        }

        return ResponseEntity.status(response.getStatus()).body(response.getResponseBody());
    }

    private void setIncorrectEmailPwdResponse(){
        response.setSuccess(false);
        response.setMessage("Incorrect email or password.");
        response.setData(null);
        response.setStatus(HttpStatus.UNAUTHORIZED);
    }

    private void getAccess(String body) throws NoSuchAlgorithmException {
        Gson data = new Gson();
        Credentials credentials = data.fromJson(body, Credentials.class);

        String userId = credentials.getUserId();
        String password = credentials.getPassword();

        Optional<User> userEnclosure = userRepository.findByEmailOrPhone(userId, userId);
        if(userEnclosure.isPresent()){
            User user = userEnclosure.get();

            String enteredPassword = Cryptography.hashValue(password);

            if(enteredPassword.equals(user.getPassword())){
                try {
                    response.setData(auth.createToken(user.getId()));
                    response.setSuccess(true);
                    response.setMessage("Logged in successfully");
                    response.setStatus(HttpStatus.ACCEPTED);
                } catch (Exception exception){
                    response.setSuccess(false);
                    response.setMessage("Failed to create token.");
                    response.setData(null);
                    response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR);

                    // Invalid Signing configuration / Couldn't convert Claims.
                    System.out.println(exception.getMessage());
                }
            }else{
                setIncorrectEmailPwdResponse();
            }
        }else {
            setIncorrectEmailPwdResponse();
        }
    }

    @PostMapping(path = "/create-token")
    public ResponseEntity<JSONObject> createToken(@RequestBody String body) throws NoSuchAlgorithmException {
        getAccess(body);
        resData.put("success", response.isSuccess());
        resData.put("message", response.getMessage());
        resData.put("data", response.getData());

        JSONObject res = new JSONObject(resData);

        return ResponseEntity.status(response.getStatus()).body(res);
    }

    @PostMapping(path = "/sign-in")
    public ResponseEntity<JSONObject> login(@RequestBody String body) throws NoSuchAlgorithmException {
        getAccess(body);
        HttpHeaders resHeaders = new HttpHeaders();
        resHeaders.add("Set-Cookie", "X-XSRF-TOKEN="+response.getData()+"; HttpOnly;");

        return ResponseEntity.status(response.getStatus()).headers(resHeaders).build();
    }

    @PostMapping(path = "/sign-up") @ResponseStatus(HttpStatus.ACCEPTED)
    public ResponseEntity<JSONObject> register(@RequestBody String body) throws ParseException, NoSuchAlgorithmException {
        Gson data = new Gson();
        User user;
        user = data.fromJson(body, User.class);

        StringBuilder errors = new StringBuilder();
        String nameValidation = Validator.validateName(user.getFirstName());

        if(nameValidation != null){
            errors.append(nameValidation);
        }

        if(!errors.isEmpty()){
            response.setSuccess(false);
            response.setMessage("Check your inputs");
            response.setData(errors.toString());
            response.setStatus(HttpStatus.UNPROCESSABLE_ENTITY);
        }else{
            byte [] md = MessageDigest.getInstance("SHA256").digest(user.getPassword().getBytes(StandardCharsets.UTF_8));
            user.setPassword(Arrays.toString(Base64.encodeBase64(md, false)));
            try{
                userRepository.save(user);
                response.setSuccess(true);
                response.setMessage("Registered successfully");
                response.setData(data.toJson(user));
                response.setStatus(HttpStatus.CREATED);
            }catch (Exception exc){
                response.setSuccess(false);
                response.setMessage("Failed to create an account.");
                response.setData(null);
                response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR);
            }
        }

        Map<String, Object> resData = new HashMap<>();
        resData.put("success", response.isSuccess());
        resData.put("message", response.getMessage());
        resData.put("data", response.getData());
        JSONObject res = new JSONObject(resData);

        return ResponseEntity.status(response.getStatus()).body(res);
    }
}
